%!TEX root = ../thesis.tex
%*******************************************************************************
%****************************** Second Chapter *********************************
%*******************************************************************************

\chapter{Variation graphs}

\ifpdf
    \graphicspath{{Chapter2/Figs/Raster/}{Chapter2/Figs/PDF/}{Chapter2/Figs/}}
\else
    \graphicspath{{Chapter2/Figs/Vector/}{Chapter2/Figs/}}
\fi

Graphical models used to compress collections of genomic sequence data are unable to losslessly reproduce their own input.
This is plainly seen by considering the an alignment graph where two homologous sequences have an internal homology between them.
Such a graph will represent four possible input sequences as walks through its nodes and edges, and without additional labeling it will be impossible to obtain its input from the graph itself \cite{kehr2014genome}.

While the input sequences exist in the set of sequences that can be generated by walks through the graph, as the complexity of the graph grows the number of paths will increase exponentially.
If annotated with transition weights between nodes representing the frequency which different edges are taken by sequences in the input, then the graph can be used as an HMM to simulate new sequences.
While these will have local similarity to the graph's preimage, they are unlikely to provide a good model for the input sequences.
Sequences generated from an HMM will exhibit an exponential decay in mutual information between their symbols, while natural sequences tend to exhibit power-law decay in mutual information \cite{lin2017critical}.
This observation suggests that no pure markovian model will allow us to faithfully represent its input, and in turn that the only way to be sure that we model the input sequence space is to maintain a record of it in the context of the graph.
The compression provided by the graph is still relevant, as we can exploit the repetitive nature of natural sequences to obtain compression of this set, but using lossless techniques.

\emph{Variation graphs}, previously introduced in section \ref{sec:the_variation_graph}, combine a bidirectional sequence graphs with paths that model their preimage as walks through the positional space of the graph.
This makes them representationally equivalent to both graphical models and linear sequence models, and allows them to be used to model the relationships between collection of sequences, including all variation contained therein.
The encapsulation of these two divergent ways of modeling about bioinformatic data systems allows them to bridge traditionally isolated analysis modalities.
We can define these graphs by their construction from a set of pairwise alignments between sequences, as in the alignment, Enredo, and Cactus graph models, but if we want to relate new sequences to them then we would need to rebuild the entire graph to include these sequences.
By developing a model for an alignment against the variation graph we can express the relationship between new sequences and the graph without the cost of embedding the new sequence in the graph.
This allows us to follow the same kinds of analysis patterns used in resequencing, where a common reference system is used to compute a form of joint assembly between (potentially) many samples in an out of core manner.
Further, in such a scheme the reference system can remain relatively stable, which has relevance for practical use.

In this chapter, I will articulate the variation graph model and lay out the algorithms and data structures that enable its use as a reference system in pangenomic resequencing.
First I will provide formulations for the graph, its paths, edits, alignments, and genotypes define within it.
Then I will present algorithms that induce the variation graph from different data models introduced in the previous chapter.
To clarify the system's practical basis, I explain the serialization techniques used to exchange variation data.
A main focus of my work has been the efficient alignment of sequences to variation graphs.
This requires index structures to store the graph and enable queries of its topology, sequence, and path spaces, and algorithms to drive the inference of optimal alignments to the graph.
Understanding variation graphs requires techniques to visualize them, and I will present various approaches, each with particular advantages and drawbacks.
Working with variation graph references necessitates a number of mutating operations to the graph, including augmentation, sorting, pruning, and bubble simplification.
Finally, I will discuss how variation graphs can provide normalized basis spaces for the analysis of pangenomes, such as through various decompositions of alignment sets and the graph including coverage maps, ultrabubble decomposition, and haplotype matching.

\section{An extensible graphical model of many sequences}

We define a variation graph to be a graph with embedded paths $G = (N, E, P)$ comprising a set of \emph{nodes} $N = n_1 \ldots n_M$, a set of \emph{edges} $E = e_1 \ldots e_L$, and a set of \emph{paths} $P = p_1 \ldots p_Q$, each of which describes the embedding of a sequence into the graph.
At its heart, this model is simply a bidirectional sequence graph with a recorded set of walks through the graph topology.
By generalizing these paths to encode edits against the graph, we provide a mechanism to describe relations between the graph and other sequences.
Augmenting the path with additional information important to sequence analysis allows us to construct an \emph{alignment}, which forms the core data type in resequencing.
Collections of pairs of paths covering the space of two graphs describe a graph to graph alignment, or \emph{translation} which can be generated when the graph is edited to allow for the projection of coordinates and sequences in one graph into the space fo the other.
A limited form of this translation is a \emph{genotype}, which maps the implied bubble formed across multiple copies of a homologus locus in one genome into the space of the graph.
Collections of genotypes are the primary output of resequencing.
Phasing algorithms extend genotypes into longer phased haplotypes, which have a natural representation as paths through the graph.
These data models thus provide a sufficient informational basis for resequencing against variation graphs.

\subsection{The bidirectional sequence graph}

Each node $n_i$ represents a sequence $seq(n_i)$ that is built from an alphabet ${ \cal A } = \{ {\tt A, C, G, T, N} \}$. Nodes may be traversed in either the forward or reverse direction, with the sequence being reverse-complemented in the reverse direction.
We write $\overline{n_i}$ for the reverse-complement of node $n_i$, so that $seq(n_i) = revcomp(seq(\overline{n_i}))$.
Note that $n_i = \overline{\overline{n}}$. For convenience, we refer to both $n_i$ and $\overline{n_i}$ as ``nodes''.

Edges represent adjacencies between the sequences of the nodes they connect.
Thus, the graph implicitly encodes longer sequences as the concatenation of node sequences along walks through the graph.
Edges can be identified with the ordered pairs of oriented nodes that they link, so we can write $e_{ij} = (n_i,n_j)$.
Edges also can be traversed in either the forward or the reverse direction, with the reverse traversal defined as $\overline{e_{ij}} = (\overline{n_j},\overline{n_i})$.
Note that graphs in vg can contain ordinary cycles (in which $n_i$ is reachable from $n_i$), reversing cycles (in which $n_i$ is reachable from $\overline{n_i}$), and non-cyclic instances of reversal (in which both $n_i$ and $\overline{n_i}$ are reachable from $n_j$).

\subsection{Paths with edits}

We implement paths as an edit string with respect to the concatenation of node subsequences along a directed walk through the graph.
We do not require the alignment described by the edit string to start at the beginning of the sequence of the initial node, nor to terminate at the end of the sequence of the terminal node.
To allow the path model to support differences from the graph, each path is composed of a series of node mappings $p_i = m_1 \ldots m_{|p_i|}$ which are semantically identical to the alignment format used by standard aligners.
Each mapping $m_i = ( b_i, \Delta_i )$ has a starting position encoded as a node and offset in the graph $b_i = ( n_j, o_i )$ and a series of edits $\Delta_i = \delta_1 \ldots \delta_{|m_i|}$.
Edits $\delta_i = ( f_i, t_i, r_i )$ represent a length $f_i$ in the graph node $n_j$ (a ``from length'' in the reference), a length $t_i$ in the sequence the path encodes (a ``to length'' in the query), and encode an additional sequence $r_i$ that would replace the sequence at the given position in the reference in order to transform it into the query.
In the case of exact matches, we allow the replacement sequence $r_i$ to be empty.
They describe a function that transforms \emph{from} the graph \emph{to} the sequence.
Edits allow for rich encoding of alleles, but in practice alignments are rendered in terms of matches, mismatches, and indels.
We encode matches when $f_i = t_i \land r_i = \emptyset$, single mismatches when $f_i = t_i = 1 \land r_i \neq \emptyset$, deletions when $f_i > 0 \land t_i < 0 \land r_i = \emptyset$, and insertions when $f_i = 0 \land t_i > 0 \land r_i \neq \emptyset$.
As paths are described by a series of mappings with independent positions, they can represent all kinds of structural variation that can be represented in the bidirectional graph itself, including translocation, inversion, and copy number variation.
When mapping positions are always at the start of a node, the edit set for the path contains only matches, and the edges traversed by the path are all present in the graph, we say that the path is \emph{embedded}.
The paths from which we construct the variation graph are fully embedded, and in practice paths that contain differences occur only in the alignment of new sequences into the graph.

\subsection{Alignments}

Additional auxiliary information is important when analyzing collections of DNA sequencing data sets.
Each read has a name, and an identity related to a particular sequencing experiment.
It may be related to a particular genomic sample or individual.
DNA sequence reads themselves result from a previous set of analyses run on raw observations derived from DNA, perhaps fluorescence or current traces or images.
The process of collapsing this raw information into the sequence read yields a confidence in addition to a base call.
These are recorded in a quality string in FASTQ.
The need to collect this information has resulted in the development of the SAM/BAM sequence alignment format, which provides a standard for linking the called bases (sequence), quality information, read name, features of the alignment against a reference genome and additional optional freeform annotations.

I follow this same model in developing an alignment format for read alignments to the graph.
An aligned set of sequences $Q$, $A = a_1 \ldots a_{|Q|}$, represents a sequencing experiment.
Each aligned read connects a sequence, an (optional) quality string, a path through the graph, and an optional set of $D_i$ annotations: $a_i = (s_i, q_i, p_i, k_1\ldots k_{D_i})$.
In principle the read sequence can be reconstructed from the path, but retaining the sequence information makes the alignment object lossless with respect to the input FASTQ and provides redundancy which can help in data processing.
Alignments may thus be reprocessed without reference to the graph to which they were aligned.
The serialization of this alignment format is called GAM, for Graphical Alignment/Map, in analogy to SAM (Sequence Alignment/Map format).

At their heart alignments redundantly link a sequence with a path through the graph.
They form the basis for operations on the graph, as new sequences mapped into the graph may be used to extend the graph itself by editing the graph to include the sequences represented by the alignments.
Just as alignments describe a function to edit the graph, they can describe the relationship between the sequence space of two graphs.

\subsection{Translations}
\label{sec:translation}

A generalization of the alignment is the translation set $\Phi = \phi_1 \ldots \phi_{|\Phi|}$, which relates paths in different graphs to describe the alignment between them.
A translation $\phi = (p_f, p_t)$ defines the projection between two paths which may arise in the context of two graphs $G_f$ and $G_t$.
In this use each $p_f$ corresponds to a path relative to $G_f$ (conventionally the base or reference graph), and each $p_t$ to some path in $G_t$.
However, both paths in each pair could be relative to the same graph, in which case translations allow us to descibe collections of allelic differences to the base graph.

If each node in both graphs is represened in some graph translation in $\Phi$ then it provides an isomorphic relationship between the coordinates and sequences in both graphs.
Provided each $\Phi$ encodes an isomorphism, then we can layer a series of $\Phi_i$ together to provide a coherent coordinate space across any number of updates to a given graph.
Consider a function pattern $translate$, which allows the projection of paths relative to $G_f$ through translations $\Phi$ to yield paths in $G_t$: $translate(p_i, \Phi) \Rightarrow p_j \in G_t$, and similarly allows the transformation of a base graph into a target graph: $translate(G_f, \Phi) \Rightarrow G_t$.
If we have a series of $(G_i, \Phi_1) \ldots (G_\sigma, \Phi_\sigma)$, where $translate(G_i, \Phi_i) \Rightarrow G_{i+1}$ and thus each $\Phi_i$ describes an isomorphism between $G_i$ and $G_{i+1}$, then we can generate a graph translation $\Phi_\Delta$ providing $translate(G_1, \Phi_\Delta) \Rightarrow G_\sigma$.
We build this graph translation with the function $layer(\Phi_\alpha, \Phi_\beta) \Rightarrow \Phi_{\alpha \cup \beta}$ by rewriting each path translation $\phi_i \in \Phi_\alpha$ so that its $p_t$ refers to $G_\beta$.
We do so by projecting the $p_t$ through $\Phi_\beta$, and finally adding any $\phi_j \in \Phi_\beta$ for which $p_f = \emptyset$, as these represent insertions of new sequence in $G_\beta$ relative to $G_\alpha$.

\subsection{Genotypes}

As path to path relationships can provide descriptions of allelic diversity, they form the basis for a graph-relative genotype encoding.
To represent the exact genotype of a particular sample with ploidy $\nu$ at a given locus $\iota$ we can simply collect the multiset of alleles $\pi_\iota = ( p_1 \ldots p_\nu)$.
We could alternatively build a probabilistic model $\varpi$ of an unphased genotype by using a set of $\mu$ alleles $\{ p_1 \ldots p_\mu\}$.
To do so we associate likelihoods $\gamma_\xi$ for each possible genotype $\pi_{\iota_\xi}$ that could be sampled from the alleles such that $\varpi = \gamma_1 \ldots \gamma_{\mu! \over{\nu!(\mu-\nu)!} }$.
In practice we develop our $\gamma_\xi$ out of quality information from the reads and a sampling model related to $\nu$ \cite{garrison2012haplotype,li2011stats}.
Given this definition of a genomic locus it is clear that existing genotyping models can be applied to drive genotyping using read sets aligned to the graph, and the output of the genotyper is defined fully in the space of the graph.

\subsection{Extending the graph}

Given an alignment $a_i$, we can edit the graph $G$ so that it includes the alignment and the sequence it represents as an embedded path, $augment(G, a_i) \Rightarrow (G', \Phi)$, such that $translate(p_i, \Phi) \in G'$.
To update the path space of the graph we project all paths, including that of $a_i$, through the translation implied by the augmentation of the graph with $p_i$.
Any other $a_j$ whose path $p_j$ overlaps $p_i$ would no longer be valid, although it could be projected through the graph translation $\Phi$ as well to express it in the space of the new graph $G'$.
Updating the graph one alignment at a time is inefficient as we need to build and layer a new translation for each alignment.
It is simpler to edit the graph in a single step, taking a collection of alignments and including them in the graph, $edit(G, A) \Rightarrow (G', \Phi)$.

One way to accomplish this is to first take the set of unique mappings represented in the paths of $A$, $\Omega = \{ m_1 \ldots m_{|\Omega|}\}$, and for each $m_i$ edit $n_i$ at the breakpoints where any new variation would need to be added in.
Then, walking through each alignment we add in unique novel sequences and their linkages to the preexisting nodes or new breakpoints to the graph.
This process will disrupt the identifier space of the nodes and edges of the graph, but it naturally yields a translation that can be used as described in section \ref{sec:translation}.

% edits allow the expansion of the graph
% a function we describe later does this
% discuss the things that happen to the graph itself

\section{Variation graph construction}
%*0.5p 0.5h*

\subsection{Progressive alignment}
%*1p 1h*

\subsection{Using variants in VCF format}
%*1.5p 1h*

\subsection{From gene models} % (GFF)
%*1p 4h*

\subsection{From multiple sequence alignments}
%*0.5p 0.5h*

\subsection{From overlap assembly and deBruijn graphs}
%*2p 1.5h*

\subsection{From pairwise alignments}
% seqwish
%*2p 4h*

\section{Data interchange}
%*0.5p 0.5h*


\section{Index structures}
%*0.5p 0.5h*

\subsection{XG index}
%*2p 3h*

\subsection{GCSA2 index}
%*1p 2h*

\subsection{Haplotype indexes}
%*1.5p 2h*

\subsection{Generic disk backed indexes}
%*0.5p 0.5h*

\subsection{Coverage index}
%*1p 1h*


\section{Sequence alignment to the graph}
%*0.5p 0.5h*

\subsection{POA and GSSW}
%*2p 2h*

\subsection{Banded global alignment}
%*0.5p 0.5h*

\subsection{X-drop DP}
%*0.5p 0.5h*

\subsection{MEM finding}
%*2p 2h*


\subsection{Collinear chaining}
%*0.5p 0.5h*

\subsection{Distance estimation}
%*1p 1h*

\subsection{MEM chaining}
%*2.5p 3h*

\subsection{Chunked alignment}
%*1p 1h*

\subsection{Alignment surjection}
%*1p 1h*


\subsection{Finding the alignment}
%*0.5p 0.5h*

\subsection{Mapping quality}
%*2p 2h*


\section{Visualization}
%*0.5p 0.5h*

\subsection{Hierarchical layout}
%*0.5p 0.5h*

\subsection{Force directed models}
%*1p 1.5h*

\subsection{Linear time visualization}
%*1p 2h*


\section{Graph mutating algorithms}
%*0.5p 0.5h*

\subsection{Edit}
%*1p 1h*

\subsection{Pruning}
%*2.5p 3h*
\subsubsection{$k$-mer complexity reduction}
\subsubsection{High degree filter}

\subsection{Graph sorting}
%*1p 1h*

\subsection{Graph simplification}
%*0.5p 0.5h*


\section{Graphs as basis spaces for sequence data}
%*2p 2h*

\subsection{Coverage maps}
%*1p 1h*

\subsection{Variant calling}
%*3p 2h*

\subsection{Bubble decompositions and likelihood spaces}
%*2p 4h*

\subsection{MEM matching to the bidirectional GBWT}
%*1p 3h*


\section{Contributions to related computational methods}

% in this chapter I've described things that I've done
% as a consequence of being in this work, here are things that I helped other people to build
% list papers, give references

% gpBWT
% GCSA2
% ...
